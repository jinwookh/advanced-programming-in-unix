# Signals

## 10.1 Introduction
Signals are software interrupts. Most nontrivial application programs need to deal with signals. Signals provide a way of handling asynchronous events-for example, a user at a terminal typing the interrupt key to stop a program or the next program in a pipeline terminating prematurely.   
...

## 10.2 Signal Concepts
...
We can tell the kernel to do one of the three things when a signal occurs. We call this the disposition of the signal, or the action associated with a signal.

1. Ignore the signal. This works for most signals, but two signals can never be ignored: SIGKILL ans SIGSTOP. The reason these two signals can't be ignored is to provide the kernel and the superuser with a surefire way of either killing or stopping any process. Also, if we ignore some of the signals that are generated by a hardware exception(such as illegal memory reference or divide by 0), the behavior of the process is undefined.   

2. Catch the signal. To do this, we tell the kernel to call a function of ours whenever the signal occurs. In our function, we can do whatever we want to handle the condition. If we're writing a command interpreter, for example, when the user generates the interrupt signal at the keyboard, we probably want to return to the main loop of the program, terminating whatever command we were executing for the user. If the SIGCHLD signal is caught, it means that a child process has terminated, so the signal-catching function can call waitpid to fetch the child's process ID and termination status.   
As another example, if the process has created temporary files, we may want to write a signal-catching function for the SIGTERM signal (the terination signal that is the default signal sent by the kill command) to clean up the temporary files. Note that the two signals SIGKILL and SIGSTOP can't be caught.

3. Let the default action apply. Every signal has a default action... Note that the default action for most signals is to terminate the process.
